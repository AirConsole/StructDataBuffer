<script>
/**
* WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!
*/

/* eslint-disable max-classes-per-file */

/**
 * A map between struct names and their type id.
 * Can for example be used for high performance code in switches.
 * @type {{number}}
 */
<%
Object.entries(structs).forEach((structEntry) => {
  const [structName, struct] = structEntry;
%><% if(struct.doc) { %>
/**
 * <%= struct.doc %>
 */<% } %>
export class <%= structName %> {
  /**
   * Creates an <%= structName %> instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   <%= structName %>.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  // eslint-disable-next-line class-methods-use-this
  typeId() {
    return <%= struct.id %>;
  }

  /**
   * Creates an ArrayBuffer including all the values<% for (let p = 0; p < struct.propertyNames.length; p += 1) {
  const prop = struct.properties[p];
  %>
   * @param {<%= propertyTypes[prop.type].isArrayBuffer ? 'ArrayBuffer' : propertyTypes[prop.type].doc %>} prop<%= prop.name %><%= prop.doc %><% } %>
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   <%= name %>(), if false, it can only be parsed by calling new <%= structName %>();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(<% if (struct.propertyNames.length) { %><%= '\n    prop' + struct.propertyNames.join(',\n    prop') + ','%><% } %>
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;<% if (!struct.hasPointers) { %>
    const len = typeOffset + <%= struct.propertiesSize %>;<% } else {%>
    let len = typeOffset + <%= struct.propertiesSize %>;
    let pointerOffset = <%= struct.propertiesSize %>;<% for (let p = 0; p < struct.propertyNames.length; p += 1) {
          const prop = struct.properties[p];
          if (prop.pointer !== undefined) {%><% if (prop.type === 'string') {%>
    const uint8Array<%= prop.name %> = new TextEncoder().encode(prop<%= prop.name %>);<% } else if (prop.type === 'JSON') { %>
    const uint8Array<%= prop.name %> = new TextEncoder().encode(JSON.stringify(prop<%= prop.name %>));<% } else if (propertyTypes[prop.type].isArrayBuffer) { %>
    const uint8Array<%= prop.name %> = new Uint8Array(prop<%= prop.name %>);<% } else if (prop.type !== 'Uint8Array') { %>
    const uint8Array<%= prop.name %> = new Uint8Array(
      prop<%= prop.name %>.buffer,
      prop<%= prop.name %>.byteOffset,
      prop<%= prop.name %>.byteLength,
    );<% } else { %>
    const uint8Array<%= prop.name %> = prop<%= prop.name %>;<% } %>
    len += uint8Array<%= prop.name %>.length;<% } %><% } } %>
    const buffer = new ArrayBuffer(len);<% if (struct.propertyNames.length) { %>
    const view = new DataView(buffer, typeOffset);<% } %><% if (struct.hasPointers) {%>
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = <%= struct.id %>;
    }<% } else { %>
    if (includeType) {
      new DataView(buffer).setUint8(0, <%= struct.id %>);
    }<% } %><% for (let p = 0; p < struct.propertyNames.length; p += 1) {
  const prop = struct.properties[p];%><% if (prop.pointer === undefined) { %>
    view.set<%= prop.type %>(<%= prop.offset %>, prop<%= prop.name%>);<% } else {%>
    uint8Array.set(uint8Array<%= prop.name %>, pointerOffset + typeOffset);
    pointerOffset += uint8Array<%= prop.name %>.byteLength;
    view.setUint32(<%= prop.offset %>, pointerOffset);<% } %><%
} %>
    return buffer;
  }<% for (let p = 0; p < struct.propertyNames.length; p += 1) {
        const prop = struct.properties[p];%>

  /**<% if (prop.doc) { %>
   * <%= prop.doc %><% } %>
   * @returns {<%= propertyTypes[prop.type].doc %>}
   */
  get<%=prop.name%>() {<% if (prop.pointer === undefined) {%>
    return this.view.get<%= prop.type%>(<%= prop.offset %>);<% } else { %>
    const offset = <%= prop.pointer === -1 ? struct.propertiesSize : 'this.view.getUint32(' + struct.properties[prop.pointer].offset + ')'%>;
    const len = <%= 'this.view.getUint32(' + prop.offset + ')' %> - offset;<% if (prop.type === 'JSON' || prop.type === 'string') { %>
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);<% if (prop.type === 'string') { %>
    return new TextDecoder().decode(dataBuffer);<% } else { %>
    return JSON.parse(new TextDecoder().decode(dataBuffer));<% }} else if (propertyTypes[prop.type].isArrayBuffer) { %>
    // eslint-disable-next-line no-use-before-define
    return <%= prop.type === name ? name : 'new ' + prop.type %>(new DataView(this.view.buffer, offset + this.view.byteOffset, len));<% } else { %>
    return new <%= prop.type %>(this.view.buffer, offset + this.view.byteOffset, len);<% }} %>
  }<% } %>
}
<% }); %>
export const TYPE_ID = {<%
Object.entries(structs).forEach((structEntry) => {
    const [structName, struct] = structEntry;
%>
  <%= structName%>: <%= struct.id%>,<% }); %>
};

/**
 * Converts an ArrayBuffer into one of the <%= name %> structs.
 * @param {ArrayBuffer|DataView|TypedArray} data
 * @returns {<%= propertyTypes[name].doc %>}
 */
export function <%= name %>(data) {
  let view;
  if (!ArrayBuffer.isView(data)) {
    view = new DataView(data);
  } else if (data instanceof DataView) {
    view = data;
  } else {
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  const dataView = new DataView(view.buffer, view.byteOffset + 1, view.byteLength - 1);
  switch (view.getUint8(0)) {<%
  Object.entries(structs).forEach((structEntry) => {
      const [structName, struct] = structEntry;
  %>
    case TYPE_ID.<%= structName%>:
      return new <%= structName %>(dataView);<% }); %>
    default:
      throw Error('Unknown struct TYPE_ID');
  }
}
</script>
