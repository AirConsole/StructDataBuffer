/**
* WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!
*/

/* eslint-disable max-classes-per-file */
/* eslint-disable class-methods-use-this */
/* eslint-disable no-bitwise */
/* eslint-disable no-use-before-define */

/**
 * A very small struct
 */
export class Simple {
  /**
   * Creates a Simple instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Simple.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 0;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {number} propA
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Simple();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propA,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    const len = typeOffset + 1;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    if (includeType) {
      new DataView(buffer).setUint8(0, 0);
    }
    view.setUint8(0, propA);
    return buffer;
  }

  /**
   * @returns {number}
   */
  getA() {
    return this.view.getUint8(0);
  }
}

/**
 * A struct with optional fields
 */
export class Optional {
  /**
   * Creates a Optional instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Optional.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 1;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {number|undefined} propOptionalUint8
   * @param {number} propRequiredUint8
   * @param {string|undefined} propOptionalString
   * @param {number|undefined} propOptionalUint16
   * @param {string} propRequiredString
   * @param {DataView|undefined} propOptionalDataView
   * @param {Object|Array|string|number|boolean|undefined} propOptionalJSON
   * @param {Uint8Array|undefined} propOptionalUint8Array
   * @param {Int8Array|undefined} propOptionalInt8Array
   * @param {ArrayBuffer|undefined} propOptionalSimple
   * @param {number|undefined} propOptionalFloat32
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Optional();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propOptionalUint8,
    propRequiredUint8,
    propOptionalString,
    propOptionalUint16,
    propRequiredString,
    propOptionalDataView,
    propOptionalJSON,
    propOptionalUint8Array,
    propOptionalInt8Array,
    propOptionalSimple,
    propOptionalFloat32,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 38;
    let pointerOffset = 38;
    let uint8ArrayOptionalString;
    if (propOptionalString !== undefined) {
      uint8ArrayOptionalString = new TextEncoder().encode(propOptionalString);
      len += uint8ArrayOptionalString.length;
    }
    const uint8ArrayRequiredString = new TextEncoder().encode(propRequiredString);
    len += uint8ArrayRequiredString.length;
    let uint8ArrayOptionalDataView;
    if (propOptionalDataView !== undefined) {
      uint8ArrayOptionalDataView = new Uint8Array(
        propOptionalDataView.buffer,
        propOptionalDataView.byteOffset,
        propOptionalDataView.byteLength,
      );
      len += uint8ArrayOptionalDataView.length;
    }
    let uint8ArrayOptionalJSON;
    if (propOptionalJSON !== undefined) {
      uint8ArrayOptionalJSON = new TextEncoder().encode(JSON.stringify(propOptionalJSON));
      len += uint8ArrayOptionalJSON.length;
    }
    let uint8ArrayOptionalUint8Array;
    if (propOptionalUint8Array !== undefined) {
      uint8ArrayOptionalUint8Array = propOptionalUint8Array;
      len += uint8ArrayOptionalUint8Array.length;
    }
    let uint8ArrayOptionalInt8Array;
    if (propOptionalInt8Array !== undefined) {
      uint8ArrayOptionalInt8Array = new Uint8Array(
        propOptionalInt8Array.buffer,
        propOptionalInt8Array.byteOffset,
        propOptionalInt8Array.byteLength,
      );
      len += uint8ArrayOptionalInt8Array.length;
    }
    let uint8ArrayOptionalSimple;
    if (propOptionalSimple !== undefined) {
      uint8ArrayOptionalSimple = new Uint8Array(propOptionalSimple);
      len += uint8ArrayOptionalSimple.length;
    }
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 1;
    }
    if (propOptionalUint8 !== undefined) {
      view.setUint8(36, view.getUint8(36) | 1);
      view.setUint8(0, propOptionalUint8);
    }
    view.setUint8(1, propRequiredUint8);
    if (propOptionalString !== undefined) {
      view.setUint8(36, view.getUint8(36) | 2);
      uint8Array.set(uint8ArrayOptionalString, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalString.byteLength;
    }
    view.setUint32(2, pointerOffset);
    if (propOptionalUint16 !== undefined) {
      view.setUint8(36, view.getUint8(36) | 4);
      view.setUint16(6, propOptionalUint16);
    }
    uint8Array.set(uint8ArrayRequiredString, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayRequiredString.byteLength;
    view.setUint32(8, pointerOffset);
    if (propOptionalDataView !== undefined) {
      view.setUint8(36, view.getUint8(36) | 8);
      uint8Array.set(uint8ArrayOptionalDataView, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalDataView.byteLength;
    }
    view.setUint32(12, pointerOffset);
    if (propOptionalJSON !== undefined) {
      view.setUint8(36, view.getUint8(36) | 16);
      uint8Array.set(uint8ArrayOptionalJSON, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalJSON.byteLength;
    }
    view.setUint32(16, pointerOffset);
    if (propOptionalUint8Array !== undefined) {
      view.setUint8(36, view.getUint8(36) | 32);
      uint8Array.set(uint8ArrayOptionalUint8Array, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalUint8Array.byteLength;
    }
    view.setUint32(20, pointerOffset);
    if (propOptionalInt8Array !== undefined) {
      view.setUint8(36, view.getUint8(36) | 64);
      uint8Array.set(uint8ArrayOptionalInt8Array, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalInt8Array.byteLength;
    }
    view.setUint32(24, pointerOffset);
    if (propOptionalSimple !== undefined) {
      view.setUint8(36, view.getUint8(36) | 128);
      uint8Array.set(uint8ArrayOptionalSimple, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalSimple.byteLength;
    }
    view.setUint32(28, pointerOffset);
    if (propOptionalFloat32 !== undefined) {
      view.setUint8(37, view.getUint8(37) | 1);
      view.setFloat32(32, propOptionalFloat32);
    }
    return buffer;
  }

  /**
   * Checks if OptionalUint8 is set
   * @returns {boolean}
   */
  hasOptionalUint8() {
    return !!(this.view.getUint8(36) & 1);
  }

  /**
   * @returns {number|undefined}
   */
  getOptionalUint8() {
    if (this.hasOptionalUint8()) {
      return this.view.getUint8(0);
    }
    return undefined;
  }

  /**
   * @returns {number}
   */
  getRequiredUint8() {
    return this.view.getUint8(1);
  }

  /**
   * Checks if OptionalString is set
   * @returns {boolean}
   */
  hasOptionalString() {
    return !!(this.view.getUint8(36) & 2);
  }

  /**
   * @returns {string|undefined}
   */
  getOptionalString() {
    if (this.hasOptionalString()) {
      const offset = 38;
      const len = this.view.getUint32(2) - offset;
      const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
      return new TextDecoder().decode(dataBuffer);
    }
    return undefined;
  }

  /**
   * Checks if OptionalUint16 is set
   * @returns {boolean}
   */
  hasOptionalUint16() {
    return !!(this.view.getUint8(36) & 4);
  }

  /**
   * @returns {number|undefined}
   */
  getOptionalUint16() {
    if (this.hasOptionalUint16()) {
      return this.view.getUint16(6);
    }
    return undefined;
  }

  /**
   * @returns {string}
   */
  getRequiredString() {
    const offset = this.view.getUint32(2);
    const len = this.view.getUint32(8) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return new TextDecoder().decode(dataBuffer);
  }

  /**
   * Checks if OptionalDataView is set
   * @returns {boolean}
   */
  hasOptionalDataView() {
    return !!(this.view.getUint8(36) & 8);
  }

  /**
   * @returns {DataView|undefined}
   */
  getOptionalDataView() {
    if (this.hasOptionalDataView()) {
      const offset = this.view.getUint32(8);
      const len = this.view.getUint32(12) - offset;
      return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
    }
    return undefined;
  }

  /**
   * Checks if OptionalJSON is set
   * @returns {boolean}
   */
  hasOptionalJSON() {
    return !!(this.view.getUint8(36) & 16);
  }

  /**
   * @returns {Object|Array|string|number|boolean|undefined}
   */
  getOptionalJSON() {
    if (this.hasOptionalJSON()) {
      const offset = this.view.getUint32(12);
      const len = this.view.getUint32(16) - offset;
      const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
      return JSON.parse(new TextDecoder().decode(dataBuffer));
    }
    return undefined;
  }

  /**
   * Checks if OptionalUint8Array is set
   * @returns {boolean}
   */
  hasOptionalUint8Array() {
    return !!(this.view.getUint8(36) & 32);
  }

  /**
   * @returns {Uint8Array|undefined}
   */
  getOptionalUint8Array() {
    if (this.hasOptionalUint8Array()) {
      const offset = this.view.getUint32(16);
      const len = this.view.getUint32(20) - offset;
      return new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    }
    return undefined;
  }

  /**
   * Checks if OptionalInt8Array is set
   * @returns {boolean}
   */
  hasOptionalInt8Array() {
    return !!(this.view.getUint8(36) & 64);
  }

  /**
   * @returns {Int8Array|undefined}
   */
  getOptionalInt8Array() {
    if (this.hasOptionalInt8Array()) {
      const offset = this.view.getUint32(20);
      const len = this.view.getUint32(24) - offset;
      return new Int8Array(this.view.buffer, offset + this.view.byteOffset, len);
    }
    return undefined;
  }

  /**
   * Checks if OptionalSimple is set
   * @returns {boolean}
   */
  hasOptionalSimple() {
    return !!(this.view.getUint8(36) & 128);
  }

  /**
   * @returns {Simple|undefined}
   */
  getOptionalSimple() {
    if (this.hasOptionalSimple()) {
      const offset = this.view.getUint32(24);
      const len = this.view.getUint32(28) - offset;
      return new Simple(new DataView(this.view.buffer, offset + this.view.byteOffset, len));
    }
    return undefined;
  }

  /**
   * Checks if OptionalFloat32 is set
   * @returns {boolean}
   */
  hasOptionalFloat32() {
    return !!(this.view.getUint8(37) & 1);
  }

  /**
   * @returns {number|undefined}
   */
  getOptionalFloat32() {
    if (this.hasOptionalFloat32()) {
      return this.view.getFloat32(32);
    }
    return undefined;
  }
}

/**
 * A struct that has children of other test struct types
 */
export class Parent {
  /**
   * Creates a Parent instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Parent.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 2;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {ArrayBuffer} propTypedChild
   * @param {ArrayBuffer} propGenericChild
   * @param {DataView} propForeignChild
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Parent();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propTypedChild,
    propGenericChild,
    propForeignChild,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 12;
    let pointerOffset = 12;
    const uint8ArrayTypedChild = new Uint8Array(propTypedChild);
    len += uint8ArrayTypedChild.length;
    const uint8ArrayGenericChild = new Uint8Array(propGenericChild);
    len += uint8ArrayGenericChild.length;
    const uint8ArrayForeignChild = new Uint8Array(
      propForeignChild.buffer,
      propForeignChild.byteOffset,
      propForeignChild.byteLength,
    );
    len += uint8ArrayForeignChild.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 2;
    }
    uint8Array.set(uint8ArrayTypedChild, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayTypedChild.byteLength;
    view.setUint32(0, pointerOffset);
    uint8Array.set(uint8ArrayGenericChild, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayGenericChild.byteLength;
    view.setUint32(4, pointerOffset);
    uint8Array.set(uint8ArrayForeignChild, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayForeignChild.byteLength;
    view.setUint32(8, pointerOffset);
    return buffer;
  }

  /**
   * @returns {Simple}
   */
  getTypedChild() {
    const offset = 12;
    const len = this.view.getUint32(0) - offset;
    return new Simple(new DataView(this.view.buffer, offset + this.view.byteOffset, len));
  }

  /**
   * @returns {Simple|Optional|Parent|Mixed|PropertyTypes}
   */
  getGenericChild() {
    const offset = this.view.getUint32(0);
    const len = this.view.getUint32(4) - offset;
    return TestStruct(new DataView(this.view.buffer, offset + this.view.byteOffset, len));
  }

  /**
   * @returns {DataView}
   */
  getForeignChild() {
    const offset = this.view.getUint32(4);
    const len = this.view.getUint32(8) - offset;
    return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
  }
}

/**
 * A small struct with mixed pointers / values
 */
export class Mixed {
  /**
   * Creates a Mixed instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Mixed.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 3;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {Int8Array} propInt8Array
   * @param {number} propUint8
   * @param {DataView} propDataView
   * @param {number} propInt8
   * @param {Object|Array|string|number|boolean} propJSON
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Mixed();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propInt8Array,
    propUint8,
    propDataView,
    propInt8,
    propJSON,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 14;
    let pointerOffset = 14;
    const uint8ArrayInt8Array = new Uint8Array(
      propInt8Array.buffer,
      propInt8Array.byteOffset,
      propInt8Array.byteLength,
    );
    len += uint8ArrayInt8Array.length;
    const uint8ArrayDataView = new Uint8Array(
      propDataView.buffer,
      propDataView.byteOffset,
      propDataView.byteLength,
    );
    len += uint8ArrayDataView.length;
    const uint8ArrayJSON = new TextEncoder().encode(JSON.stringify(propJSON));
    len += uint8ArrayJSON.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 3;
    }
    uint8Array.set(uint8ArrayInt8Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayInt8Array.byteLength;
    view.setUint32(0, pointerOffset);
    view.setUint8(4, propUint8);
    uint8Array.set(uint8ArrayDataView, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayDataView.byteLength;
    view.setUint32(5, pointerOffset);
    view.setInt8(9, propInt8);
    uint8Array.set(uint8ArrayJSON, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayJSON.byteLength;
    view.setUint32(10, pointerOffset);
    return buffer;
  }

  /**
   * @returns {Int8Array}
   */
  getInt8Array() {
    const offset = 14;
    const len = this.view.getUint32(0) - offset;
    return new Int8Array(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {number}
   */
  getUint8() {
    return this.view.getUint8(4);
  }

  /**
   * @returns {DataView}
   */
  getDataView() {
    const offset = this.view.getUint32(0);
    const len = this.view.getUint32(5) - offset;
    return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {number}
   */
  getInt8() {
    return this.view.getInt8(9);
  }

  /**
   * @returns {Object|Array|string|number|boolean}
   */
  getJSON() {
    const offset = this.view.getUint32(5);
    const len = this.view.getUint32(10) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return JSON.parse(new TextDecoder().decode(dataBuffer));
  }
}

/**
 * All allowed builtin types
 */
export class PropertyTypes {
  /**
   * Creates a PropertyTypes instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   PropertyTypes.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 4;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {number} propUint8
   * @param {number} propUint16
   * @param {number} propUint32
   * @param {BigInt} propBigUint64
   * @param {number} propInt8
   * @param {number} propInt16
   * @param {number} propInt32
   * @param {BigInt} propBigInt64
   * @param {number} propFloat32
   * @param {number} propFloat64
   * @param {string} propString
   * @param {Object|Array|string|number|boolean} propJSON
   * @param {DataView} propDataView
   * @param {Int8Array} propInt8Array
   * @param {Uint8Array} propUint8Array
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new PropertyTypes();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propUint8,
    propUint16,
    propUint32,
    propBigUint64,
    propInt8,
    propInt16,
    propInt32,
    propBigInt64,
    propFloat32,
    propFloat64,
    propString,
    propJSON,
    propDataView,
    propInt8Array,
    propUint8Array,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 62;
    let pointerOffset = 62;
    const uint8ArrayString = new TextEncoder().encode(propString);
    len += uint8ArrayString.length;
    const uint8ArrayJSON = new TextEncoder().encode(JSON.stringify(propJSON));
    len += uint8ArrayJSON.length;
    const uint8ArrayDataView = new Uint8Array(
      propDataView.buffer,
      propDataView.byteOffset,
      propDataView.byteLength,
    );
    len += uint8ArrayDataView.length;
    const uint8ArrayInt8Array = new Uint8Array(
      propInt8Array.buffer,
      propInt8Array.byteOffset,
      propInt8Array.byteLength,
    );
    len += uint8ArrayInt8Array.length;
    const uint8ArrayUint8Array = propUint8Array;
    len += uint8ArrayUint8Array.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 4;
    }
    view.setUint8(0, propUint8);
    view.setUint16(1, propUint16);
    view.setUint32(3, propUint32);
    view.setBigUint64(7, propBigUint64);
    view.setInt8(15, propInt8);
    view.setInt16(16, propInt16);
    view.setInt32(18, propInt32);
    view.setBigInt64(22, propBigInt64);
    view.setFloat32(30, propFloat32);
    view.setFloat64(34, propFloat64);
    uint8Array.set(uint8ArrayString, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayString.byteLength;
    view.setUint32(42, pointerOffset);
    uint8Array.set(uint8ArrayJSON, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayJSON.byteLength;
    view.setUint32(46, pointerOffset);
    uint8Array.set(uint8ArrayDataView, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayDataView.byteLength;
    view.setUint32(50, pointerOffset);
    uint8Array.set(uint8ArrayInt8Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayInt8Array.byteLength;
    view.setUint32(54, pointerOffset);
    uint8Array.set(uint8ArrayUint8Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayUint8Array.byteLength;
    view.setUint32(58, pointerOffset);
    return buffer;
  }

  /**
   * @returns {number}
   */
  getUint8() {
    return this.view.getUint8(0);
  }

  /**
   * @returns {number}
   */
  getUint16() {
    return this.view.getUint16(1);
  }

  /**
   * @returns {number}
   */
  getUint32() {
    return this.view.getUint32(3);
  }

  /**
   * @returns {BigInt}
   */
  getBigUint64() {
    return this.view.getBigUint64(7);
  }

  /**
   * @returns {number}
   */
  getInt8() {
    return this.view.getInt8(15);
  }

  /**
   * @returns {number}
   */
  getInt16() {
    return this.view.getInt16(16);
  }

  /**
   * @returns {number}
   */
  getInt32() {
    return this.view.getInt32(18);
  }

  /**
   * @returns {BigInt}
   */
  getBigInt64() {
    return this.view.getBigInt64(22);
  }

  /**
   * @returns {number}
   */
  getFloat32() {
    return this.view.getFloat32(30);
  }

  /**
   * @returns {number}
   */
  getFloat64() {
    return this.view.getFloat64(34);
  }

  /**
   * @returns {string}
   */
  getString() {
    const offset = 62;
    const len = this.view.getUint32(42) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return new TextDecoder().decode(dataBuffer);
  }

  /**
   * @returns {Object|Array|string|number|boolean}
   */
  getJSON() {
    const offset = this.view.getUint32(42);
    const len = this.view.getUint32(46) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return JSON.parse(new TextDecoder().decode(dataBuffer));
  }

  /**
   * @returns {DataView}
   */
  getDataView() {
    const offset = this.view.getUint32(46);
    const len = this.view.getUint32(50) - offset;
    return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {Int8Array}
   */
  getInt8Array() {
    const offset = this.view.getUint32(50);
    const len = this.view.getUint32(54) - offset;
    return new Int8Array(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {Uint8Array}
   */
  getUint8Array() {
    const offset = this.view.getUint32(54);
    const len = this.view.getUint32(58) - offset;
    return new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
  }
}

/**
 * A map between struct names and their type id.
 * Can for example be used for high performance code in switches.
 * @type {{number}}
 */
export const TYPE_ID = {
  Simple: 0,
  Optional: 1,
  Parent: 2,
  Mixed: 3,
  PropertyTypes: 4,
};

/**
 * Converts an ArrayBuffer into one of the TestStruct structs.
 * @param {ArrayBuffer|DataView|TypedArray} data
 * @returns {Simple|Optional|Parent|Mixed|PropertyTypes}
 */
export function TestStruct(data) {
  let view;
  if (!ArrayBuffer.isView(data)) {
    view = new DataView(data);
  } else if (data instanceof DataView) {
    view = data;
  } else {
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  const dataView = new DataView(view.buffer, view.byteOffset + 1, view.byteLength - 1);
  switch (view.getUint8(0)) {
    case TYPE_ID.Simple:
      return new Simple(dataView);
    case TYPE_ID.Optional:
      return new Optional(dataView);
    case TYPE_ID.Parent:
      return new Parent(dataView);
    case TYPE_ID.Mixed:
      return new Mixed(dataView);
    case TYPE_ID.PropertyTypes:
      return new PropertyTypes(dataView);
    default:
      throw Error('Unknown struct TYPE_ID');
  }
}
