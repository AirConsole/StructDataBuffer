/**
 * WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!
 * To update this file use the StructDataBuffer tool on:
 * https://github.com/AirConsole/StructDataBuffer
*/

/* eslint-disable max-classes-per-file */
/* eslint-disable class-methods-use-this */
/* eslint-disable no-bitwise */
/* eslint-disable no-use-before-define */
/* eslint-disable max-len */

/**
 * A very small struct
 */
export class Simple {
  /**
   * Creates a Simple instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Simple.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 0;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {number} propA
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Simple();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propA,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    const len = typeOffset + 1;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    if (includeType) {
      new DataView(buffer).setUint8(0, 0);
    }
    view.setUint8(0, propA);
    return buffer;
  }

  /**
   * @returns {number}
   */
  getA() {
    return this.view.getUint8(0);
  }
}

/**
 * A struct with optional fields
 */
export class Optional {
  /**
   * Creates a Optional instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Optional.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 1;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {number|undefined} propOptionalUint8
   * @param {number} propRequiredUint8
   * @param {string|undefined} propOptionalString
   * @param {number|undefined} propOptionalUint16
   * @param {string} propRequiredString
   * @param {DataView|undefined} propOptionalDataView
   * @param {Object|Array|string|number|boolean|undefined} propOptionalJSON
   * @param {Uint8Array|undefined} propOptionalUint8Array
   * @param {Int8Array|undefined} propOptionalInt8Array
   * @param {ArrayBuffer|undefined} propOptionalSimple
   * @param {number|undefined} propOptionalFloat32
   * @param {boolean} propRequiredBoolean
   * @param {boolean|undefined} propOptionalBoolean
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Optional();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propOptionalUint8,
    propRequiredUint8,
    propOptionalString,
    propOptionalUint16,
    propRequiredString,
    propOptionalDataView,
    propOptionalJSON,
    propOptionalUint8Array,
    propOptionalInt8Array,
    propOptionalSimple,
    propOptionalFloat32,
    propRequiredBoolean,
    propOptionalBoolean,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 38;
    let pointerOffset = 38;
    let uint8ArrayOptionalString;
    if (propOptionalString !== undefined) {
      uint8ArrayOptionalString = new TextEncoder().encode(propOptionalString);
      len += uint8ArrayOptionalString.length;
    }
    const uint8ArrayRequiredString = new TextEncoder().encode(propRequiredString);
    len += uint8ArrayRequiredString.length;
    let uint8ArrayOptionalDataView;
    if (propOptionalDataView !== undefined) {
      uint8ArrayOptionalDataView = new Uint8Array(
        propOptionalDataView.buffer,
        propOptionalDataView.byteOffset,
        propOptionalDataView.byteLength,
      );
      len += uint8ArrayOptionalDataView.length;
    }
    let uint8ArrayOptionalJSON;
    if (propOptionalJSON !== undefined) {
      uint8ArrayOptionalJSON = new TextEncoder().encode(JSON.stringify(propOptionalJSON));
      len += uint8ArrayOptionalJSON.length;
    }
    let uint8ArrayOptionalUint8Array;
    if (propOptionalUint8Array !== undefined) {
      uint8ArrayOptionalUint8Array = propOptionalUint8Array;
      len += uint8ArrayOptionalUint8Array.length;
    }
    let uint8ArrayOptionalInt8Array;
    if (propOptionalInt8Array !== undefined) {
      uint8ArrayOptionalInt8Array = new Uint8Array(
        propOptionalInt8Array.buffer,
        propOptionalInt8Array.byteOffset,
        propOptionalInt8Array.byteLength,
      );
      len += uint8ArrayOptionalInt8Array.length;
    }
    let uint8ArrayOptionalSimple;
    if (propOptionalSimple !== undefined) {
      uint8ArrayOptionalSimple = new Uint8Array(propOptionalSimple);
      len += uint8ArrayOptionalSimple.length;
    }
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 1;
    }
    if (propOptionalUint8 !== undefined) {
      view.setUint8(36, view.getUint8(36) | 1);
      view.setUint8(0, propOptionalUint8);
    }
    view.setUint8(1, propRequiredUint8);
    if (propOptionalString !== undefined) {
      view.setUint8(36, view.getUint8(36) | 2);
      uint8Array.set(uint8ArrayOptionalString, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalString.byteLength;
    }
    view.setUint32(2, pointerOffset);
    if (propOptionalUint16 !== undefined) {
      view.setUint8(36, view.getUint8(36) | 4);
      view.setUint16(6, propOptionalUint16);
    }
    uint8Array.set(uint8ArrayRequiredString, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayRequiredString.byteLength;
    view.setUint32(8, pointerOffset);
    if (propOptionalDataView !== undefined) {
      view.setUint8(36, view.getUint8(36) | 8);
      uint8Array.set(uint8ArrayOptionalDataView, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalDataView.byteLength;
    }
    view.setUint32(12, pointerOffset);
    if (propOptionalJSON !== undefined) {
      view.setUint8(36, view.getUint8(36) | 16);
      uint8Array.set(uint8ArrayOptionalJSON, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalJSON.byteLength;
    }
    view.setUint32(16, pointerOffset);
    if (propOptionalUint8Array !== undefined) {
      view.setUint8(36, view.getUint8(36) | 32);
      uint8Array.set(uint8ArrayOptionalUint8Array, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalUint8Array.byteLength;
    }
    view.setUint32(20, pointerOffset);
    if (propOptionalInt8Array !== undefined) {
      view.setUint8(36, view.getUint8(36) | 64);
      uint8Array.set(uint8ArrayOptionalInt8Array, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalInt8Array.byteLength;
    }
    view.setUint32(24, pointerOffset);
    if (propOptionalSimple !== undefined) {
      view.setUint8(36, view.getUint8(36) | 128);
      uint8Array.set(uint8ArrayOptionalSimple, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayOptionalSimple.byteLength;
    }
    view.setUint32(28, pointerOffset);
    if (propOptionalFloat32 !== undefined) {
      view.setUint8(37, view.getUint8(37) | 1);
      view.setFloat32(32, propOptionalFloat32);
    }
    if (propRequiredBoolean) {
      view.setUint8(37, view.getUint8(37) | 2);
    }
    if (propOptionalBoolean !== undefined) {
      view.setUint8(37, view.getUint8(37) | 4);
      if (propOptionalBoolean) {
        view.setUint8(37, view.getUint8(37) | 8);
      }
    }
    return buffer;
  }

  /**
   * Checks if OptionalUint8 is set
   * @returns {boolean}
   */
  hasOptionalUint8() {
    return !!(this.view.getUint8(36) & 1);
  }

  /**
   * @returns {number|undefined}
   */
  getOptionalUint8() {
    if (this.hasOptionalUint8()) {
      return this.view.getUint8(0);
    }
    return undefined;
  }

  /**
   * @returns {number}
   */
  getRequiredUint8() {
    return this.view.getUint8(1);
  }

  /**
   * Checks if OptionalString is set
   * @returns {boolean}
   */
  hasOptionalString() {
    return !!(this.view.getUint8(36) & 2);
  }

  /**
   * @returns {string|undefined}
   */
  getOptionalString() {
    if (this.hasOptionalString()) {
      const offset = 38;
      const len = this.view.getUint32(2) - offset;
      const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
      return new TextDecoder().decode(dataBuffer);
    }
    return undefined;
  }

  /**
   * Checks if OptionalUint16 is set
   * @returns {boolean}
   */
  hasOptionalUint16() {
    return !!(this.view.getUint8(36) & 4);
  }

  /**
   * @returns {number|undefined}
   */
  getOptionalUint16() {
    if (this.hasOptionalUint16()) {
      return this.view.getUint16(6);
    }
    return undefined;
  }

  /**
   * @returns {string}
   */
  getRequiredString() {
    const offset = this.view.getUint32(2);
    const len = this.view.getUint32(8) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return new TextDecoder().decode(dataBuffer);
  }

  /**
   * Checks if OptionalDataView is set
   * @returns {boolean}
   */
  hasOptionalDataView() {
    return !!(this.view.getUint8(36) & 8);
  }

  /**
   * @returns {DataView|undefined}
   */
  getOptionalDataView() {
    if (this.hasOptionalDataView()) {
      const offset = this.view.getUint32(8);
      const len = this.view.getUint32(12) - offset;
      return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
    }
    return undefined;
  }

  /**
   * Checks if OptionalJSON is set
   * @returns {boolean}
   */
  hasOptionalJSON() {
    return !!(this.view.getUint8(36) & 16);
  }

  /**
   * @returns {Object|Array|string|number|boolean|undefined}
   */
  getOptionalJSON() {
    if (this.hasOptionalJSON()) {
      const offset = this.view.getUint32(12);
      const len = this.view.getUint32(16) - offset;
      const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
      return JSON.parse(new TextDecoder().decode(dataBuffer));
    }
    return undefined;
  }

  /**
   * Checks if OptionalUint8Array is set
   * @returns {boolean}
   */
  hasOptionalUint8Array() {
    return !!(this.view.getUint8(36) & 32);
  }

  /**
   * @returns {Uint8Array|undefined}
   */
  getOptionalUint8Array() {
    if (this.hasOptionalUint8Array()) {
      const offset = this.view.getUint32(16);
      const len = this.view.getUint32(20) - offset;
      return new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    }
    return undefined;
  }

  /**
   * Checks if OptionalInt8Array is set
   * @returns {boolean}
   */
  hasOptionalInt8Array() {
    return !!(this.view.getUint8(36) & 64);
  }

  /**
   * @returns {Int8Array|undefined}
   */
  getOptionalInt8Array() {
    if (this.hasOptionalInt8Array()) {
      const offset = this.view.getUint32(20);
      const len = this.view.getUint32(24) - offset;
      return new Int8Array(this.view.buffer, offset + this.view.byteOffset, len);
    }
    return undefined;
  }

  /**
   * Checks if OptionalSimple is set
   * @returns {boolean}
   */
  hasOptionalSimple() {
    return !!(this.view.getUint8(36) & 128);
  }

  /**
   * @returns {Simple|undefined}
   */
  getOptionalSimple() {
    if (this.hasOptionalSimple()) {
      const offset = this.view.getUint32(24);
      const len = this.view.getUint32(28) - offset;
      const start = offset + this.view.byteOffset;
      return new Simple(new DataView(this.view.buffer, start, len));
    }
    return undefined;
  }

  /**
   * Checks if OptionalFloat32 is set
   * @returns {boolean}
   */
  hasOptionalFloat32() {
    return !!(this.view.getUint8(37) & 1);
  }

  /**
   * @returns {number|undefined}
   */
  getOptionalFloat32() {
    if (this.hasOptionalFloat32()) {
      return this.view.getFloat32(32);
    }
    return undefined;
  }

  /**
   * @returns {boolean}
   */
  getRequiredBoolean() {
    return !!(this.view.getUint8(37) & 2);
  }

  /**
   * Checks if OptionalBoolean is set
   * @returns {boolean}
   */
  hasOptionalBoolean() {
    return !!(this.view.getUint8(37) & 4);
  }

  /**
   * @returns {boolean|undefined}
   */
  getOptionalBoolean() {
    if (this.hasOptionalBoolean()) {
      return !!(this.view.getUint8(37) & 8);
    }
    return undefined;
  }
}

/**
 * A struct that has children of other test struct types
 */
export class Parent {
  /**
   * Creates a Parent instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Parent.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 2;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {ArrayBuffer} propTypedChild
   * @param {ArrayBuffer} propGenericChild
   * @param {DataView} propForeignChild
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Parent();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propTypedChild,
    propGenericChild,
    propForeignChild,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 12;
    let pointerOffset = 12;
    const uint8ArrayTypedChild = new Uint8Array(propTypedChild);
    len += uint8ArrayTypedChild.length;
    const uint8ArrayGenericChild = new Uint8Array(propGenericChild);
    len += uint8ArrayGenericChild.length;
    const uint8ArrayForeignChild = new Uint8Array(
      propForeignChild.buffer,
      propForeignChild.byteOffset,
      propForeignChild.byteLength,
    );
    len += uint8ArrayForeignChild.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 2;
    }
    uint8Array.set(uint8ArrayTypedChild, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayTypedChild.byteLength;
    view.setUint32(0, pointerOffset);
    uint8Array.set(uint8ArrayGenericChild, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayGenericChild.byteLength;
    view.setUint32(4, pointerOffset);
    uint8Array.set(uint8ArrayForeignChild, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayForeignChild.byteLength;
    view.setUint32(8, pointerOffset);
    return buffer;
  }

  /**
   * @returns {Simple}
   */
  getTypedChild() {
    const offset = 12;
    const len = this.view.getUint32(0) - offset;
    const start = offset + this.view.byteOffset;
    return new Simple(new DataView(this.view.buffer, start, len));
  }

  /**
   * @returns {Simple|Optional|Parent|Mixed|Align|UnalignedParent|PropertyTypes}
   */
  getGenericChild() {
    const offset = this.view.getUint32(0);
    const len = this.view.getUint32(4) - offset;
    const start = offset + this.view.byteOffset;
    return TestStruct(new DataView(this.view.buffer, start, len));
  }

  /**
   * @returns {DataView}
   */
  getForeignChild() {
    const offset = this.view.getUint32(4);
    const len = this.view.getUint32(8) - offset;
    return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
  }
}

/**
 * A small struct with mixed pointers / values
 */
export class Mixed {
  /**
   * Creates a Mixed instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Mixed.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 3;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {Int8Array} propInt8Array
   * @param {number} propUint8
   * @param {DataView} propDataView
   * @param {number} propInt8
   * @param {Object|Array|string|number|boolean} propJSON
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Mixed();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propInt8Array,
    propUint8,
    propDataView,
    propInt8,
    propJSON,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 14;
    let pointerOffset = 14;
    const uint8ArrayInt8Array = new Uint8Array(
      propInt8Array.buffer,
      propInt8Array.byteOffset,
      propInt8Array.byteLength,
    );
    len += uint8ArrayInt8Array.length;
    const uint8ArrayDataView = new Uint8Array(
      propDataView.buffer,
      propDataView.byteOffset,
      propDataView.byteLength,
    );
    len += uint8ArrayDataView.length;
    const uint8ArrayJSON = new TextEncoder().encode(JSON.stringify(propJSON));
    len += uint8ArrayJSON.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 3;
    }
    uint8Array.set(uint8ArrayInt8Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayInt8Array.byteLength;
    view.setUint32(0, pointerOffset);
    view.setUint8(4, propUint8);
    uint8Array.set(uint8ArrayDataView, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayDataView.byteLength;
    view.setUint32(5, pointerOffset);
    view.setInt8(9, propInt8);
    uint8Array.set(uint8ArrayJSON, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayJSON.byteLength;
    view.setUint32(10, pointerOffset);
    return buffer;
  }

  /**
   * @returns {Int8Array}
   */
  getInt8Array() {
    const offset = 14;
    const len = this.view.getUint32(0) - offset;
    return new Int8Array(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {number}
   */
  getUint8() {
    return this.view.getUint8(4);
  }

  /**
   * @returns {DataView}
   */
  getDataView() {
    const offset = this.view.getUint32(0);
    const len = this.view.getUint32(5) - offset;
    return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {number}
   */
  getInt8() {
    return this.view.getInt8(9);
  }

  /**
   * @returns {Object|Array|string|number|boolean}
   */
  getJSON() {
    const offset = this.view.getUint32(5);
    const len = this.view.getUint32(10) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return JSON.parse(new TextDecoder().decode(dataBuffer));
  }
}

/**
 * Testing byte alignment
 */
export class Align {
  /**
   * Creates a Align instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Align.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 4;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {string|undefined} propGap1
   * @param {Uint32Array} propAligned
   * @param {string} propGap2
   * @param {Uint32Array} propUnaligned
   * @param {ArrayBuffer|undefined} propChild
   * @param {DataView|undefined} propDataView
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new Align();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propGap1,
    propAligned,
    propGap2,
    propUnaligned,
    propChild,
    propDataView,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 25;
    let pointerOffset = 25;
    let uint8ArrayGap1;
    if (propGap1 !== undefined) {
      uint8ArrayGap1 = new TextEncoder().encode(propGap1);
      len += uint8ArrayGap1.length;
    }
    const paddingAligned = 4 - ((len % 4) || 4);
    len += paddingAligned;
    const uint8ArrayAligned = new Uint8Array(
      propAligned.buffer,
      propAligned.byteOffset,
      propAligned.byteLength,
    );
    len += uint8ArrayAligned.length;
    const uint8ArrayGap2 = new TextEncoder().encode(propGap2);
    len += uint8ArrayGap2.length;
    const uint8ArrayUnaligned = new Uint8Array(
      propUnaligned.buffer,
      propUnaligned.byteOffset,
      propUnaligned.byteLength,
    );
    len += uint8ArrayUnaligned.length;
    let uint8ArrayChild;
    let paddingChild = 0;
    if (propChild !== undefined) {
      paddingChild = 4 - ((len % 4) || 4);
      len += paddingChild;
      uint8ArrayChild = new Uint8Array(propChild);
      len += uint8ArrayChild.length;
    }
    let uint8ArrayDataView;
    let paddingDataView = 0;
    if (propDataView !== undefined) {
      paddingDataView = 4 - ((len % 4) || 4);
      len += paddingDataView;
      uint8ArrayDataView = new Uint8Array(
        propDataView.buffer,
        propDataView.byteOffset,
        propDataView.byteLength,
      );
      len += uint8ArrayDataView.length;
    }
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 4;
    }
    if (propGap1 !== undefined) {
      view.setUint8(24, view.getUint8(24) | 1);
      uint8Array.set(uint8ArrayGap1, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayGap1.byteLength;
    }
    view.setUint32(0, pointerOffset);
    pointerOffset += paddingAligned;
    uint8Array.set(uint8ArrayAligned, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayAligned.byteLength;
    view.setUint32(4, pointerOffset);
    uint8Array.set(uint8ArrayGap2, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayGap2.byteLength;
    view.setUint32(8, pointerOffset);
    uint8Array.set(uint8ArrayUnaligned, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayUnaligned.byteLength;
    view.setUint32(12, pointerOffset);
    if (propChild !== undefined) {
      view.setUint8(24, view.getUint8(24) | 2);
      pointerOffset += paddingChild;
      uint8Array.set(uint8ArrayChild, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayChild.byteLength;
    }
    view.setUint32(16, pointerOffset);
    if (propDataView !== undefined) {
      view.setUint8(24, view.getUint8(24) | 4);
      pointerOffset += paddingDataView;
      uint8Array.set(uint8ArrayDataView, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayDataView.byteLength;
    }
    view.setUint32(20, pointerOffset);
    return buffer;
  }

  /**
   * Checks if Gap1 is set
   * @returns {boolean}
   */
  hasGap1() {
    return !!(this.view.getUint8(24) & 1);
  }

  /**
   * @returns {string|undefined}
   */
  getGap1() {
    if (this.hasGap1()) {
      const offset = 25;
      const len = this.view.getUint32(0) - offset;
      const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
      return new TextDecoder().decode(dataBuffer);
    }
    return undefined;
  }

  /**
   * @returns {Uint32Array}
   */
  getAligned() {
    const offset = this.view.getUint32(0);
    const end = this.view.getUint32(4);
    let len = end - offset;
    len -= len % 4;
    const start = end - len + this.view.byteOffset;
    if (start % 4 === 0) {
      return new Uint32Array(this.view.buffer, start, len / 4);
    }
    return new Uint32Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {string}
   */
  getGap2() {
    const offset = this.view.getUint32(4);
    const len = this.view.getUint32(8) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return new TextDecoder().decode(dataBuffer);
  }

  /**
   * @returns {Uint32Array}
   */
  getUnaligned() {
    const offset = this.view.getUint32(8);
    const len = this.view.getUint32(12) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 4 === 0) {
      return new Uint32Array(this.view.buffer, start, len / 4);
    }
    return new Uint32Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * Checks if Child is set
   * @returns {boolean}
   */
  hasChild() {
    return !!(this.view.getUint8(24) & 2);
  }

  /**
   * @returns {Align|undefined}
   */
  getChild() {
    if (this.hasChild()) {
      const offset = this.view.getUint32(12);
      const end = this.view.getUint32(16);
      let len = end - offset;
      len -= len % 4;
      const start = end - len + this.view.byteOffset;
      return new Align(new DataView(this.view.buffer, start, len));
    }
    return undefined;
  }

  /**
   * Checks if DataView is set
   * @returns {boolean}
   */
  hasDataView() {
    return !!(this.view.getUint8(24) & 4);
  }

  /**
   * @returns {DataView|undefined}
   */
  getDataView() {
    if (this.hasDataView()) {
      const offset = this.view.getUint32(16);
      const end = this.view.getUint32(20);
      let len = end - offset;
      len -= len % 4;
      const start = end - len + this.view.byteOffset;
      if (start % 4 === 0) {
        return new DataView(this.view.buffer, start, len);
      }
      return new DataView(this.view.buffer.slice(start, start + len));
    }
    return undefined;
  }
}

/**
 * A parent that doesn&#39;t align the child
 */
export class UnalignedParent {
  /**
   * Creates a UnalignedParent instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   UnalignedParent.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 5;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {ArrayBuffer|undefined} propChild
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new UnalignedParent();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propChild,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 5;
    let pointerOffset = 5;
    let uint8ArrayChild;
    if (propChild !== undefined) {
      uint8ArrayChild = new Uint8Array(propChild);
      len += uint8ArrayChild.length;
    }
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 5;
    }
    if (propChild !== undefined) {
      view.setUint8(4, view.getUint8(4) | 1);
      uint8Array.set(uint8ArrayChild, pointerOffset + typeOffset);
      pointerOffset += uint8ArrayChild.byteLength;
    }
    view.setUint32(0, pointerOffset);
    return buffer;
  }

  /**
   * Checks if Child is set
   * @returns {boolean}
   */
  hasChild() {
    return !!(this.view.getUint8(4) & 1);
  }

  /**
   * @returns {Align|undefined}
   */
  getChild() {
    if (this.hasChild()) {
      const offset = 5;
      const len = this.view.getUint32(0) - offset;
      const start = offset + this.view.byteOffset;
      return new Align(new DataView(this.view.buffer, start, len));
    }
    return undefined;
  }
}

/**
 * All allowed builtin types
 */
export class PropertyTypes {
  /**
   * Creates a PropertyTypes instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   PropertyTypes.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 6;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {number} propUint8
   * @param {number} propUint16
   * @param {number} propUint32
   * @param {BigInt} propBigUint64
   * @param {number} propInt8
   * @param {number} propInt16
   * @param {number} propInt32
   * @param {BigInt} propBigInt64
   * @param {number} propFloat32
   * @param {number} propFloat64
   * @param {string} propString
   * @param {Object|Array|string|number|boolean} propJSON
   * @param {DataView} propDataView
   * @param {Int8Array} propInt8Array
   * @param {Uint8Array} propUint8Array
   * @param {Int16Array} propInt16Array
   * @param {Uint16Array} propUint16Array
   * @param {Int32Array} propInt32Array
   * @param {Uint32Array} propUint32Array
   * @param {BigInt64Array} propBigInt64Array
   * @param {BigUint64Array} propBigUint64Array
   * @param {Float32Array} propFloat32Array
   * @param {Float64Array} propFloat64Array
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   TestStruct(), if false, it can only be parsed by calling new PropertyTypes();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propUint8,
    propUint16,
    propUint32,
    propBigUint64,
    propInt8,
    propInt16,
    propInt32,
    propBigInt64,
    propFloat32,
    propFloat64,
    propString,
    propJSON,
    propDataView,
    propInt8Array,
    propUint8Array,
    propInt16Array,
    propUint16Array,
    propInt32Array,
    propUint32Array,
    propBigInt64Array,
    propBigUint64Array,
    propFloat32Array,
    propFloat64Array,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 94;
    let pointerOffset = 94;
    const uint8ArrayString = new TextEncoder().encode(propString);
    len += uint8ArrayString.length;
    const uint8ArrayJSON = new TextEncoder().encode(JSON.stringify(propJSON));
    len += uint8ArrayJSON.length;
    const uint8ArrayDataView = new Uint8Array(
      propDataView.buffer,
      propDataView.byteOffset,
      propDataView.byteLength,
    );
    len += uint8ArrayDataView.length;
    const uint8ArrayInt8Array = new Uint8Array(
      propInt8Array.buffer,
      propInt8Array.byteOffset,
      propInt8Array.byteLength,
    );
    len += uint8ArrayInt8Array.length;
    const uint8ArrayUint8Array = propUint8Array;
    len += uint8ArrayUint8Array.length;
    const uint8ArrayInt16Array = new Uint8Array(
      propInt16Array.buffer,
      propInt16Array.byteOffset,
      propInt16Array.byteLength,
    );
    len += uint8ArrayInt16Array.length;
    const uint8ArrayUint16Array = new Uint8Array(
      propUint16Array.buffer,
      propUint16Array.byteOffset,
      propUint16Array.byteLength,
    );
    len += uint8ArrayUint16Array.length;
    const uint8ArrayInt32Array = new Uint8Array(
      propInt32Array.buffer,
      propInt32Array.byteOffset,
      propInt32Array.byteLength,
    );
    len += uint8ArrayInt32Array.length;
    const uint8ArrayUint32Array = new Uint8Array(
      propUint32Array.buffer,
      propUint32Array.byteOffset,
      propUint32Array.byteLength,
    );
    len += uint8ArrayUint32Array.length;
    const uint8ArrayBigInt64Array = new Uint8Array(
      propBigInt64Array.buffer,
      propBigInt64Array.byteOffset,
      propBigInt64Array.byteLength,
    );
    len += uint8ArrayBigInt64Array.length;
    const uint8ArrayBigUint64Array = new Uint8Array(
      propBigUint64Array.buffer,
      propBigUint64Array.byteOffset,
      propBigUint64Array.byteLength,
    );
    len += uint8ArrayBigUint64Array.length;
    const uint8ArrayFloat32Array = new Uint8Array(
      propFloat32Array.buffer,
      propFloat32Array.byteOffset,
      propFloat32Array.byteLength,
    );
    len += uint8ArrayFloat32Array.length;
    const uint8ArrayFloat64Array = new Uint8Array(
      propFloat64Array.buffer,
      propFloat64Array.byteOffset,
      propFloat64Array.byteLength,
    );
    len += uint8ArrayFloat64Array.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 6;
    }
    view.setUint8(0, propUint8);
    view.setUint16(1, propUint16);
    view.setUint32(3, propUint32);
    view.setBigUint64(7, propBigUint64);
    view.setInt8(15, propInt8);
    view.setInt16(16, propInt16);
    view.setInt32(18, propInt32);
    view.setBigInt64(22, propBigInt64);
    view.setFloat32(30, propFloat32);
    view.setFloat64(34, propFloat64);
    uint8Array.set(uint8ArrayString, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayString.byteLength;
    view.setUint32(42, pointerOffset);
    uint8Array.set(uint8ArrayJSON, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayJSON.byteLength;
    view.setUint32(46, pointerOffset);
    uint8Array.set(uint8ArrayDataView, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayDataView.byteLength;
    view.setUint32(50, pointerOffset);
    uint8Array.set(uint8ArrayInt8Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayInt8Array.byteLength;
    view.setUint32(54, pointerOffset);
    uint8Array.set(uint8ArrayUint8Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayUint8Array.byteLength;
    view.setUint32(58, pointerOffset);
    uint8Array.set(uint8ArrayInt16Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayInt16Array.byteLength;
    view.setUint32(62, pointerOffset);
    uint8Array.set(uint8ArrayUint16Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayUint16Array.byteLength;
    view.setUint32(66, pointerOffset);
    uint8Array.set(uint8ArrayInt32Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayInt32Array.byteLength;
    view.setUint32(70, pointerOffset);
    uint8Array.set(uint8ArrayUint32Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayUint32Array.byteLength;
    view.setUint32(74, pointerOffset);
    uint8Array.set(uint8ArrayBigInt64Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayBigInt64Array.byteLength;
    view.setUint32(78, pointerOffset);
    uint8Array.set(uint8ArrayBigUint64Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayBigUint64Array.byteLength;
    view.setUint32(82, pointerOffset);
    uint8Array.set(uint8ArrayFloat32Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayFloat32Array.byteLength;
    view.setUint32(86, pointerOffset);
    uint8Array.set(uint8ArrayFloat64Array, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayFloat64Array.byteLength;
    view.setUint32(90, pointerOffset);
    return buffer;
  }

  /**
   * @returns {number}
   */
  getUint8() {
    return this.view.getUint8(0);
  }

  /**
   * @returns {number}
   */
  getUint16() {
    return this.view.getUint16(1);
  }

  /**
   * @returns {number}
   */
  getUint32() {
    return this.view.getUint32(3);
  }

  /**
   * @returns {BigInt}
   */
  getBigUint64() {
    return this.view.getBigUint64(7);
  }

  /**
   * @returns {number}
   */
  getInt8() {
    return this.view.getInt8(15);
  }

  /**
   * @returns {number}
   */
  getInt16() {
    return this.view.getInt16(16);
  }

  /**
   * @returns {number}
   */
  getInt32() {
    return this.view.getInt32(18);
  }

  /**
   * @returns {BigInt}
   */
  getBigInt64() {
    return this.view.getBigInt64(22);
  }

  /**
   * @returns {number}
   */
  getFloat32() {
    return this.view.getFloat32(30);
  }

  /**
   * @returns {number}
   */
  getFloat64() {
    return this.view.getFloat64(34);
  }

  /**
   * @returns {string}
   */
  getString() {
    const offset = 94;
    const len = this.view.getUint32(42) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return new TextDecoder().decode(dataBuffer);
  }

  /**
   * @returns {Object|Array|string|number|boolean}
   */
  getJSON() {
    const offset = this.view.getUint32(42);
    const len = this.view.getUint32(46) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return JSON.parse(new TextDecoder().decode(dataBuffer));
  }

  /**
   * @returns {DataView}
   */
  getDataView() {
    const offset = this.view.getUint32(46);
    const len = this.view.getUint32(50) - offset;
    return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {Int8Array}
   */
  getInt8Array() {
    const offset = this.view.getUint32(50);
    const len = this.view.getUint32(54) - offset;
    return new Int8Array(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {Uint8Array}
   */
  getUint8Array() {
    const offset = this.view.getUint32(54);
    const len = this.view.getUint32(58) - offset;
    return new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
  }

  /**
   * @returns {Int16Array}
   */
  getInt16Array() {
    const offset = this.view.getUint32(58);
    const len = this.view.getUint32(62) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 2 === 0) {
      return new Int16Array(this.view.buffer, start, len / 2);
    }
    return new Int16Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {Uint16Array}
   */
  getUint16Array() {
    const offset = this.view.getUint32(62);
    const len = this.view.getUint32(66) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 2 === 0) {
      return new Uint16Array(this.view.buffer, start, len / 2);
    }
    return new Uint16Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {Int32Array}
   */
  getInt32Array() {
    const offset = this.view.getUint32(66);
    const len = this.view.getUint32(70) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 4 === 0) {
      return new Int32Array(this.view.buffer, start, len / 4);
    }
    return new Int32Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {Uint32Array}
   */
  getUint32Array() {
    const offset = this.view.getUint32(70);
    const len = this.view.getUint32(74) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 4 === 0) {
      return new Uint32Array(this.view.buffer, start, len / 4);
    }
    return new Uint32Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {BigInt64Array}
   */
  getBigInt64Array() {
    const offset = this.view.getUint32(74);
    const len = this.view.getUint32(78) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 8 === 0) {
      return new BigInt64Array(this.view.buffer, start, len / 8);
    }
    return new BigInt64Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {BigUint64Array}
   */
  getBigUint64Array() {
    const offset = this.view.getUint32(78);
    const len = this.view.getUint32(82) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 8 === 0) {
      return new BigUint64Array(this.view.buffer, start, len / 8);
    }
    return new BigUint64Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {Float32Array}
   */
  getFloat32Array() {
    const offset = this.view.getUint32(82);
    const len = this.view.getUint32(86) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 4 === 0) {
      return new Float32Array(this.view.buffer, start, len / 4);
    }
    return new Float32Array(this.view.buffer.slice(start, start + len));
  }

  /**
   * @returns {Float64Array}
   */
  getFloat64Array() {
    const offset = this.view.getUint32(86);
    const len = this.view.getUint32(90) - offset;
    const start = offset + this.view.byteOffset;
    if (start % 8 === 0) {
      return new Float64Array(this.view.buffer, start, len / 8);
    }
    return new Float64Array(this.view.buffer.slice(start, start + len));
  }
}

/**
 * A map between struct names and their type id.
 * Can for example be used for high performance code in switches.
 * @type {{number}}
 */
export const TYPE_ID = {
  Simple: 0,
  Optional: 1,
  Parent: 2,
  Mixed: 3,
  Align: 4,
  UnalignedParent: 5,
  PropertyTypes: 6,
};

/**
 * Converts an ArrayBuffer into one of the TestStruct structs.
 * @param {ArrayBuffer|DataView|TypedArray} data
 * @returns {Simple|Optional|Parent|Mixed|Align|UnalignedParent|PropertyTypes}
 */
export function TestStruct(data) {
  let view;
  if (!ArrayBuffer.isView(data)) {
    view = new DataView(data);
  } else if (data instanceof DataView) {
    view = data;
  } else {
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  const dataView = new DataView(view.buffer, view.byteOffset + 1, view.byteLength - 1);
  switch (view.getUint8(0)) {
    case TYPE_ID.Simple:
      return new Simple(dataView);
    case TYPE_ID.Optional:
      return new Optional(dataView);
    case TYPE_ID.Parent:
      return new Parent(dataView);
    case TYPE_ID.Mixed:
      return new Mixed(dataView);
    case TYPE_ID.Align:
      return new Align(dataView);
    case TYPE_ID.UnalignedParent:
      return new UnalignedParent(dataView);
    case TYPE_ID.PropertyTypes:
      return new PropertyTypes(dataView);
    default:
      throw Error('Unknown struct TYPE_ID');
  }
}
