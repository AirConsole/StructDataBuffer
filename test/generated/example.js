/**
* WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!
*/

/* eslint-disable max-classes-per-file */
/* eslint-disable class-methods-use-this */
/* eslint-disable no-bitwise */
/* eslint-disable no-use-before-define */

/**
 * A player inside a world
 */
export class Player {
  /**
   * Creates a Player instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Player.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 0;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {string} propName The name of the player
   * @param {number|undefined} propAge The age of the player (optional)
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   MyGameObjects(), if false, it can only be parsed by calling new Player();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propName,
    propAge,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 6;
    let pointerOffset = 6;
    const uint8ArrayName = new TextEncoder().encode(propName);
    len += uint8ArrayName.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 0;
    }
    uint8Array.set(uint8ArrayName, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayName.byteLength;
    view.setUint32(0, pointerOffset);
    if (propAge !== undefined) {
      view.setUint8(5, view.getUint8(5) | 1);
      view.setUint8(4, propAge);
    }
    return buffer;
  }

  /**
   *  The name of the player
   * @returns {string}
   */
  getName() {
    const offset = 6;
    const len = this.view.getUint32(0) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return new TextDecoder().decode(dataBuffer);
  }

  /**
   * Checks if Age is set
   * @returns {boolean}
   */
  hasAge() {
    return !!(this.view.getUint8(5) & 1);
  }

  /**
   *  The age of the player (optional)
   * @returns {number|undefined}
   */
  getAge() {
    if (this.hasAge()) {
      return this.view.getUint8(4);
    }
    return undefined;
  }
}

/**
 * A house in the world
 */
export class House {
  /**
   * Creates a House instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   House.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 1;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {ArrayBuffer} propOwner Who owns the house
   * @param {Object|Array|string|number|boolean} propAddress A JSON representing the address
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   MyGameObjects(), if false, it can only be parsed by calling new House();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propOwner,
    propAddress,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 8;
    let pointerOffset = 8;
    const uint8ArrayOwner = new Uint8Array(propOwner);
    len += uint8ArrayOwner.length;
    const uint8ArrayAddress = new TextEncoder().encode(JSON.stringify(propAddress));
    len += uint8ArrayAddress.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 1;
    }
    uint8Array.set(uint8ArrayOwner, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayOwner.byteLength;
    view.setUint32(0, pointerOffset);
    uint8Array.set(uint8ArrayAddress, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayAddress.byteLength;
    view.setUint32(4, pointerOffset);
    return buffer;
  }

  /**
   *  Who owns the house
   * @returns {Player}
   */
  getOwner() {
    const offset = 8;
    const len = this.view.getUint32(0) - offset;
    return new Player(new DataView(this.view.buffer, offset + this.view.byteOffset, len));
  }

  /**
   *  A JSON representing the address
   * @returns {Object|Array|string|number|boolean}
   */
  getAddress() {
    const offset = this.view.getUint32(0);
    const len = this.view.getUint32(4) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return JSON.parse(new TextDecoder().decode(dataBuffer));
  }
}

/**
 * A map between struct names and their type id.
 * Can for example be used for high performance code in switches.
 * @type {{number}}
 */
export const TYPE_ID = {
  Player: 0,
  House: 1,
};

/**
 * Converts an ArrayBuffer into one of the MyGameObjects structs.
 * @param {ArrayBuffer|DataView|TypedArray} data
 * @returns {Player|House}
 */
export function MyGameObjects(data) {
  let view;
  if (!ArrayBuffer.isView(data)) {
    view = new DataView(data);
  } else if (data instanceof DataView) {
    view = data;
  } else {
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  const dataView = new DataView(view.buffer, view.byteOffset + 1, view.byteLength - 1);
  switch (view.getUint8(0)) {
    case TYPE_ID.Player:
      return new Player(dataView);
    case TYPE_ID.House:
      return new House(dataView);
    default:
      throw Error('Unknown struct TYPE_ID');
  }
}
