/**
* WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!
*/

/* eslint-disable max-classes-per-file */

/**
 * A map between struct names and their type id.
 * Can for example be used for high performance code in switches.
 * @type {{number}}
 */

export class Test {
  /**
   * Creates an Test instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Test.pack(..., includeType=false);
   */
  constructor(data) {
    if (!ArrayBuffer.isView(data)) {
      this.view = new DataView(data);
    } else if (data instanceof DataView) {
      this.view = data;
    } else {
      this.view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  // eslint-disable-next-line class-methods-use-this
  typeId() {
    return 0;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {number} propPlace
   * @param {Object|Array|string|number|boolean} propTime
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   NoDoc(), if false, it can only be parsed by calling new Test();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propPlace,
    propTime,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 6;
    let pointerOffset = 6;
    const uint8ArrayTime = new TextEncoder().encode(JSON.stringify(propTime));
    len += uint8ArrayTime.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 0;
    }
    view.setUint16(0, propPlace);
    uint8Array.set(uint8ArrayTime, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayTime.byteLength;
    view.setUint32(2, pointerOffset);
    return buffer;
  }

  /**
   * @returns {number}
   */
  getPlace() {
    return this.view.getUint16(0);
  }

  /**
   * @returns {Object|Array|string|number|boolean}
   */
  getTime() {
    const offset = 6;
    const len = this.view.getUint32(2) - offset;
    const dataBuffer = new Uint8Array(this.view.buffer, offset + this.view.byteOffset, len);
    return JSON.parse(new TextDecoder().decode(dataBuffer));
  }
}

export const TYPE_ID = {
  Test: 0,
};

/**
 * Converts an ArrayBuffer into one of the NoDoc structs.
 * @param {ArrayBuffer|DataView|TypedArray} data
 * @returns {Test}
 */
export function NoDoc(data) {
  let view;
  if (!ArrayBuffer.isView(data)) {
    view = new DataView(data);
  } else if (data instanceof DataView) {
    view = data;
  } else {
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  const dataView = new DataView(view.buffer, view.byteOffset + 1, view.byteLength - 1);
  switch (view.getUint8(0)) {
    case TYPE_ID.Test:
      return new Test(dataView);
    default:
      throw Error('Unknown struct TYPE_ID');
  }
}
