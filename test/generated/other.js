/**
 * WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!
 * To update this file use the StructDataBuffer tool on:
 * https://github.com/AirConsole/StructDataBuffer
*/

/* eslint-disable max-classes-per-file */
/* eslint-disable class-methods-use-this */
/* eslint-disable no-bitwise */
/* eslint-disable no-use-before-define */
/* eslint-disable max-len */
/**
 * Converts a ArrayBuffer|DataView|TypedArray to a Dataview
 * @param {ArrayBuffer|DataView|TypedArray} data
 * @returns {DataView}
 */
function convertToDataView(data) {
  if (!ArrayBuffer.isView(data)) {
    return new DataView(data);
  }
  if (data instanceof DataView) {
    return data;
  }
  return new DataView(data.buffer, data.byteOffset, data.byteLength);
}

/**
 * A mansion in another world.
 */
export class Mansion {
  /**
   * Creates a Mansion instance to access the different properties.
   * @param {ArrayBuffer|DataView|TypedArray} data The data array created by calling
   *   Mansion.pack(..., includeType=false);
   */
  constructor(data) {
    this.view = convertToDataView(data);
  }

  /**
   * Returns the type id of this struct.
   * Can be used for example in switch statements together with TYPES.
   * @returns {number}
   */
  typeId() {
    return 0;
  }

  /**
   * Creates an ArrayBuffer including all the values
   * @param {DataView} propPlayer A player from another input file
   * @param {boolean} [includeType] If true, the returned ArrayBuffer can only be parsed by
   *   OtherGameObjects(), if false, it can only be parsed by calling new Mansion();
   *   Default: false
   * @returns {ArrayBuffer}
   */
  static pack(
    propPlayer,
    includeType,
  ) {
    const typeOffset = includeType ? 1 : 0;
    let len = typeOffset + 4;
    let pointerOffset = 4;
    const uint8ArrayPlayer = new Uint8Array(
      propPlayer.buffer,
      propPlayer.byteOffset,
      propPlayer.byteLength,
    );
    len += uint8ArrayPlayer.length;
    const buffer = new ArrayBuffer(len);
    const view = new DataView(buffer, typeOffset);
    const uint8Array = new Uint8Array(buffer);
    if (includeType) {
      uint8Array[0] = 0;
    }
    uint8Array.set(uint8ArrayPlayer, pointerOffset + typeOffset);
    pointerOffset += uint8ArrayPlayer.byteLength;
    view.setUint32(0, pointerOffset);
    return buffer;
  }

  /**
   *  A player from another input file
   * @returns {DataView}
   */
  getPlayer() {
    const offset = 4;
    const len = this.view.getUint32(0) - offset;
    return new DataView(this.view.buffer, offset + this.view.byteOffset, len);
  }
}

/**
 * A map between struct names and their type id.
 * Can for example be used for high performance code in switches.
 * @type {{number}}
 */
export const TYPE_ID = {
  Mansion: 0,
};

/**
 * Converts an ArrayBuffer into one of the OtherGameObjects structs.
 * @param {ArrayBuffer|DataView|TypedArray} data
 * @returns {Mansion}
 */
export function OtherGameObjects(data) {
  const view = convertToDataView(data);
  const dataView = new DataView(view.buffer, view.byteOffset + 1, view.byteLength - 1);
  switch (view.getUint8(0)) {
    case TYPE_ID.Mansion:
      return new Mansion(dataView);
    default:
      throw Error('Unknown struct TYPE_ID');
  }
}
